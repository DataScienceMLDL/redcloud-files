Entonces tenemos un tag_based_file_system

Tenemos una distribucion de carpetas de la siguiente forma:
/internal/api         HTTP handlers (misma API en 1ª y 2ª entrega)
/internal/catalog     SQLite + índice invertido en RAM (aun no tenemos sqlite para catalog estoy usando primero diccionarios guardando en memoria directamente todavia como primer paso)
/internal/store       blobs CAS en disco
/internal/query       Intersección de sets
/internal/gc          Garbage Collector


Primero respecto a los blobs:
Un BLOB se refiere a una unidad de base de datos compuesta por un grupo de datos binarios. 
Se utilizan principalmente para guardar objetos multimedia como archivos de vídeo, sonido e imagen. 
Sin embargo, algunos sistemas de gestión de bases de datos (SGBD) podrían no ser compatibles con este tipo de blobs.
Además, los datos no estructurados, como texto y datos binarios, pueden almacenarse en grandes volúmenes mediante servicios en la nube como Azure Blob Storage.

En principio se estan guardando los archivos en blobs con la funcion StoreBlob en /internal/main.go 

Respecto a los catalogs:
Estos son una forma de guardar los metadatos de los blobs digamos un tesis.pdf lo guardamos como blob esto da un blobId:acv212 
Este id seria el unico conocimiento q tenemos del archivo.pdf con el catalog guardamos el metadato es decir mas informacion.
Guardamos el blobID, el nombre del fichero es decir tesis.pdf y los tags digamos Tags: {tesis,escuela}.

Por ahora se refactorizo la idea simple de Metadata dentro de catalog y se siguio la idea de filenodes y tagnodes del paper
Separare Files y tags (strucs/type)
FileNode → sabe qué tags tiene (referencias por TagID).
TagNode → sabe qué archivos tiene (FileID).
Para buscar por tag → solo consultas un TagNode y obtienes directamente los archivos (O(1) para acceso + O(k) para recorrer sus FileIDs). Muchísimo más rápido.
De esta forma la búsqueda de archivos por tag es directa.
Cada tag existe una sola vez.




